# -*- coding: utf-8 -*-
"""spear.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1mEYc2gmiFKndU6dIhgVZ877PYGn4iqy4
"""

"""Imports"""

from spear.labeling import labeling_function, ABSTAIN, preprocessor
import enum
import os 
import uuid
import numpy as np
import cv2
import json

"""Preprocessing Functions"""

def segment_patch(filename):
    unique_file = filename[:-4] + str(uuid.uuid4())+".jpg"
    os.system(f'python3 demo.py --input {filename} --output {unique_file} --maxIter 1000 --minLabels 2')
    return unique_file

def contour_patch(og_patch,segmented_patch):
  img = cv2.imread(segmented_patch, cv2.IMREAD_UNCHANGED)
  img_grey = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
  thresh = 176
  ret,thresh_img = cv2.threshold(img_grey, thresh, 255, cv2.THRESH_BINARY)
  contours, hierarchy = cv2.findContours(thresh_img, cv2.RETR_TREE, cv2.CHAIN_APPROX_SIMPLE)
  boxes = []
  new_dir = "patches"+segmented_patch[:-4][segmented_patch[:-4].rfind("/"):]
  try:
    os.mkdir(new_dir) # -4 cause last 4 characters of extension are removed
  except:
    pass
  og_img = cv2.imread(og_patch, cv2.IMREAD_UNCHANGED)
  for i in range(len(contours)):
    contour = contours[i]
    x,y,w,h = cv2.boundingRect(contour)
    boxes.append([x,y,w,h])
    cropped_img = og_img[y:y+h, x:x+w]
    # cv2_imshow(cropped_img)
    cv2.imwrite(f"{new_dir}/{i}.jpg",cropped_img)
  for box in boxes:
    x,y,w,h = box
    cv2.rectangle(og_img, (x, y), (x + w, y + h), (255,0,0), 4)
    
  cv2.imwrite(f"{new_dir}.jpg",og_img)
  return new_dir,boxes

def preprocess(filename):
  seg_file = segment_patch(filename)
  new_dir,boxes = contour_patch(filename, seg_file)
  return new_dir,boxes



"""Labelling Functions"""

# Should be added to config file
spacing = 0.25

# enum to hold the class labels
class ClassLabels(enum.Enum):
    NUC = 1
    CEL = 0
    RSC = 2

@labeling_function(label=ClassLabels.NUC)
def nucleus(cropped): 
    cpd_img = cv2.imread(cropped)
    h, w, c = cpd_img.shape
    if h*w >10/(spacing**2) and h*w < 40/(spacing**2):
      # print((h*w)*(spacing**2))
      return ClassLabels.NUC
    else:
      return ABSTAIN

@labeling_function(label=ClassLabels.CEL)
def cell(cropped): 
    cpd_img = cv2.imread(cropped)
    h, w, c = cpd_img.shape
    if h*w >70/(spacing**2):
      return ClassLabels.CEL
    else:
      return ABSTAIN

@labeling_function(label=ClassLabels.RSC)
def reed_steinberg(cropped): 
    cpd_img = cv2.imread(cropped)
    h, w, c = cpd_img.shape
    if h*w >40/(spacing**2) and h*w < 70/(spacing**2):
      # print((h*w)*(spacing**2))
      # cv2_imshow(cpd_img)
      return ClassLabels.RSC
    else:
      return ABSTAIN

pname = "patches/patch2bbe6ddea-76c4-4e19-a12c-c964c182b184"
print(len(os.listdir(pname)))
count = 0
for fil in os.listdir(pname):
  x = reed_steinberg(os.path.join(pname, fil))
  if x[0]:
    count+=1

print("Count", count)

from spear.labeling import LFSet

LFS = [nucleus, cell, reed_steinberg]

rules = LFSet("HL")
rules.add_lf_list(LFS)

from spear.labeling import PreLabels
pname = "patches/patch2bbe6ddea-76c4-4e19-a12c-c964c182b184"
nucleus_labels = PreLabels(name="HL",
                               data=np.array([os.path.join(pname, fil) for fil in os.listdir(pname)]),
                               rules=rules,
                              #  gold_labels=np.ones(277),
                               labels_enum=ClassLabels,
                               num_classes=3)

labels,S = nucleus_labels.get_labels()


"""Annotations in Label Studio Format"""

def anns(patches,anns,labels,id):
  for patch in patches:
    p_img = cv2.imread(patch)
    h, w, c = p_img.shape

    img_dict = {}
    img_dict["id"] = id
    img_dict["data"] = {"image": patch}
    ann_id=0
    res = [] 
    for ann in anns:
      ann = {}
      ann["image_rotation"] = 0
      ann["original_width"] = w
      ann["original_height"] = h
      ann["id"] = ann_id
      ann["from_name"] = "label"
      ann["to_name"] = "image"
      ann["type"] = "rectanglelabels"
      if 2 in labels[ann_id]:
        label = "RSC"
        ann_id+=1
      elif 1 in labels[ann_id]:
        label = "Nucleus"
        ann_id+=1
      else:
        ann_id+=1
        continue
        
      ann["value"] = {"x": anns[ann_id][0],"y": anns[ann_id][1], "width": anns[ann_id][2],"height": anns[ann_id][3],"rotation": 0, "rectanglelabels": [label]}
      res.append(ann)

    img_dict["predictions"] = [{"id": 1, "model_version": "one", "created_ago": "0 minutes", "result": res}]
  return img_dict

"""Patch Function"""


"""Main Function"""

def main(patches):
  # patches is a list of filenames of the patches

  # Suggestions for pipeline
  # Call a function here to get patches, like this
  # patches = get_patches()
  # After this remove the patches argument for this function
  # You may create another section above this for all the functions required to get the list of patches

  # Initalization for Annotations
  ls_anns = []
  id = 0

  # Iterate over all patches
  for patch in patches:
    pname,boxes = preprocess(patch)
    nucleus_labels = PreLabels(name="HL",
                               data=np.array([os.path.join(pname, fil) for fil in os.listdir(pname)]),
                               rules=rules,
                              #  gold_labels=np.ones(277),
                               labels_enum=ClassLabels,
                               num_classes=3)
    labels,S = nucleus_labels.get_labels()
    ls_anns.append(anns(patch,boxes,labels))
    id+=1
  ls_json = json.dumps(ls_anns)
  return ls_json

json_dict = main(["patch2.jpg"])
# The name of the output json file can be taken as input from the user
json_file = "sample.json"
with open(json_file, "w") as outfile:
    json.dump(json_dict, outfile)
